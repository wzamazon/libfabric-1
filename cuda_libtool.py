#!/usr/bin/env python
# This script a .cu file to .lo file like libtool does
from os import path, system
from sys import argv, exit
from subprocess import getoutput

lofile = argv[1]
o_file = lofile.replace(".lo", ".o")

outdir = path.dirname(lofile)
o_file = path.basename(o_file)

pic_dir = outdir + "/.libs"
pic_obj_file = outdir + "/.libs/" + o_file
nonpic_obj_file = outdir + "/" + o_file

if not path.exists(pic_dir):
    system("mkdir -p " + pic_dir)

# generate the command to compile the .cu for shared library
pic_command = ""
for arg in argv[2:]:
    pic_command += arg + " "
pic_command += " -Xcompiler -fPIC -o " + pic_obj_file
#print("run:", pic_command)

# compile the .cu
ret = system(pic_command)
if ret != 0:
    exit(1)

# generate the command to compile the .cu for static library
nonpic_command = ""
for arg in argv[2:]:
    nonpic_command += arg + " "
nonpic_command += " -o " + nonpic_obj_file
#print("Command:", nonpic_command)

# compile the .cu
rv = system(nonpic_command)
if rv != 0:
    exit(1)

lt_title = getoutput("./libtool --version | head -n 1")

# generate the .lo file
f = open(lofile, "w")
print("# " +  lofile + " - a libtool object file", file=f)
print("# Generated by " + lt_title, file=f)
print("#", file=f)
print("# Please DO NOT delete this file!", file=f)
print("# It is necessary for linking the library.", file=f)
print("", file=f)
print("# Name of the PIC object.", file=f)
print("pic_object='.libs/%s'" % o_file, file=f)
print("", file=f)
print("# Name of the non-PIC object.", file=f)
print("non_pic_object='%s'" % o_file, file=f)


